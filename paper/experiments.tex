\section{Experiments}
\label{sec:design}

    \subsection{Permissions Misuse}
    
        Many Android applications misuse permissions that they
        allow their applications to possess. Often, certain
        permissions are granted to an app that doesn't use them
        in the first place. This practice is dangerous: it can 
        leave vulnerabilities within the application that should
        not be possible based on the actual functionality of the
        application. For example, it would be easy for a 
        developer to add functionality to an app that requires a
        certain permission, and then leave the permission in after
        reverting their previous changes. 
        
        Another common theme seen within applications
        is the combination of two permissions that can create a 
        dangerous comibination. For example, a malicious 
        application with the permission combination of
        CAMERA and RECORD\_AUDIO would allow the application
        to have access to a devices camera and microphone, tools
        that would be able to perform serious invasions of privacy. 
        Another example could be seen with INTERNET and 
        ACCESS\_FINE\_LOCATION, which would grant an application the
        ability to track a device's physical location (and 
        subsequently serve as a tool for stalking).

        The ability of permissions to allow an application within
        reach of sensitive data means that users should be prompted
        whether they wish to allow certain permissions to be enabled.
        However, many applications do not give users the chance to 
        make this decision; this choice is a significant breach of trust 
        between an application and its users.

        All of these developer mistakes constitute permission vulnerabilities
        within Android applications. For our first experiment, we
        will be testing these common misuses of permissions. First, 
        the experiment will test whether apps utilize all of the
        permissions that they request. Second, the experiment will 
        search for the use of dangerous permission combinations
        implemented in the app. Finally, the experiment will test whether
        users are prompted to explicity give their consent to every
        permission used.
        
        Setup: 
        
        For this experiment, we first looked into whether the app abided by the 
        principle  of least privilege. Out of all permissions that the app asked 
        for, we checked how many were used and how many were unused. When permissions 
        were found to be requested, but never used throughout the app, this signified
        that the app did not follow the principle of least privilege, as unnecessary 
        permissions were included in the app. 

        We also checked to make sure that all permissions that were included in the app
        were requested, providing transparency about the permissions that the app 
        utilized. 

        Finally, we checked for dangerous permission combinations in the 
        applications. We specificially looked for combinations of RECORD\_AUDIO and 
        INTERNET, ACCESS\_FINE\_LOCATION and RECEIVE\_BOOT\_COMPLETED, CAMERA and 
        INTERNET, as well as SEND\_SMS and WRITE\_SMS. 

    \subsection{Trust Managers and Error Handlers}

        Trust Managers are put in place to verify the authenticity of a 
        remote server. To do this, many Android built-in trust managers 
        are implemented to securely verify a server's certificate.
        However, the built-in X509TrustManager class allows the complete 
        override of the server verification process, potentially endangering
        an application if implemented incorrectly.

        Many times, developers will avoid the built-in trust manager in an
        effort to take shortcuts around the correct implementation (whether
        this be for convenience or lack of experience). This practice is often
        carried out by implementing the checkServerTrusted() function in a way 
        that configures the hostname verifier to trust all X.509 certificates. 
        By doing this, developers expose their application to danger; 
        third parties may attempt a Man-in-the-Middle attack on network traffic
        from the application, compromising a user's network data if successful.

        TALK ABOUT ERROR HANDLING HERE

        This experiment will be testing whether or not an app overrides a built-in
        trust manager or error handler to forgo methods intended purpose of
        correctly verifying certificates.

        Setup:

        For this experiment, we utilized Androguard and aspects of Mallodroid to
        check if built-in trust manager or error handler methods, specifically
        checkServerTrusted() and onReceivedSslError(), were overriden.

    \subsection{AllowAllHostnameVerifier}
    
        The HostnameVerifier interface within Android Studio is responsible for the 
        verification of the hostname within the server being connected to, making 
        sure the hostname within the server's certificate matches the one 
        seen in the server the client is attempting to connect to. 

        A vulnerability arises when the developer attempts to shortcut the 
        hostname verification process (similar to Experiment 2), resulting 
        in an ineffective verification process. Specifically, many 
        developers use the AllowAllHostnameVerifier class; this class 
        essentially turns hostname verification off (by allowing all 
        hostnames) and instructs the process to never throw an SSL 
        Exception.

        This vulnerability, similar to avoiding trust managers, creates 
        the opportunity for a Man-in-the-Middle attack. If the host 
        cannot be verified, a third-party has the opportunity to impersonate
        a legitimate server and trick the application into sending 
        sensitive data to it.

        This experiment will test whether or not an application 
        implements the AllowAllHostnameVerifier class, which allows 
        all hostnames to be accepted for a certificate.

        Setup:

        For this experiment, we made use of Androguard to analyze an app's 
        method instructions, checking if the AllowAllHostnameVerifier class was ever 
        implemented. Specifically we looked for AllowAllHostnameVerifier and 
        SSLSocketFactory\;\-\>ALLOW\_ALL\_HOSTNAME\_VERIFIER, similar to Mallodroid.


    \subsection{Mixed use SSL}

        When an application is connected to the internet, it is not 
        good practice to used both HTTPS and HTTP. HTTPS connections 
        are more secure since they use Secure Sockets Layer (SSL) to 
        encrypt normal HTTP requests and responses, which consist of 
        only plaintext messages. When HTTP content is loaded by an 
        HTTPS page, attackers have the opportunity to read and/or modify
        HTTP traffic. This results in a mixed-use SSL vulnerability.

        Developers create this vulnerability when they do not ensure 
        that every resource on their page is loaded over HTTPS, and 
        this can prove tricky; modern websites often load several 
        different resources from various places, making it hard to 
        keep track of where HTTPS and HTTP is used. Many times, the 
        solution (for a developer) is to simply place an "s" within 
        "http://" to apply SSl to it. The consequence of this vulnerability 
        is the potential for an attacker to perform a Man-in-the-Middle 
        attack.

        In this experiment, we will test whether or not an application is 
        using a mixture of HTTP and HTTPS protocal when loading content.

        Setup:

        For this experiment, we will parse through class files to locate
        instances where the developer is using certain libraries (such as 
        "HttpURLConnection"), and whether or not said libraries are configured
        to use HTTPS consistently. This will involve string searches for 
        "http://" and "https://" to see whether an app is only using HTTP (or
        if it is mixed use).

    \subsection{addJavascriptInterface Method}

        Many applications use WebViews as a way to display web pages as a 
        part of their activity layout. The addJavascriptInterface method 
        is subsequently used to inject a supplied Java object into a WebView. 
        This process allows JavaScript to control the host application, 
        but presents a significant security threat if a developer is not 
        using the interface only where necessary. 

        The vulnerability arises when a malicious 3rd-party seeks to use 
        the webview as a bridge into the users system. If a webview were to
        contain untrusted content, an attacker could use it to manipulate the
        host application in unintended ways. This is done by injecting JavaScript 
        into a user's system and running the malicious code.
        
        By using the @JavascriptInterface annotation, developers can use the interface
        only where necessary and avoid allowing untrusted content within webviews.

        This experiment will test whether or not the application is being exposed to
        potentially dangerous outside sources, depending on if the application is
        using a webview.

        Setup

        For this experiment, we will use keyword searches to locate instances of 
        the addJavascriptInterface() method. If it is successfully found, we will 
        subsequently search for the use of the @JavascriptInterface annotation, confirming
        whether or not the developer is using the method responsibly.